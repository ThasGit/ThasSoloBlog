{"relevantArticles":[{"articleTitle":"JAVA 对象头","articleAbstractText":"对象头结构  偏向锁与 hash 不能共存， 一旦计算过 hash, 对象就不可偏向。 对象头中的 bl:1 代表是否可偏向， 若不可偏向， 则前 56 位可以用来表示 hash 值， 若可偏向， 则前 56 位必不表示 hash 值， 可以用来表示偏向的线程 ID  Object 没有属性， 所以除了对象头就没有其他内容了， 根据 8 字节对齐， 自动填充了 4 字节 Object[]数组会额外使用 4 字节保存长度， 所以数组的最大长度为整形; 后面则是顺序存储的全部元素的指针， 由于开启了指针压缩， 每个都是 4 个字节。  指针压缩 32 位 CPU 的最大寻址空间为 2^32, 如果这些寻址空间指向 bit 位， 那么最大支持的内存为 512M; 但是 CPU 存储数据的时候都是以 8bit 为一组， 也就是 1byte; 把寻址空间指向 byte 组， 就可以让最大支持内存增加到 4G. JVM 指针压缩原理相同。 64 位 JVM 最大寻址空间是 2^64, 寻址空间指向 byte 组， 则最大可支持 2^34G 内存; 但是存储 64 位指针会让内存占用提高。 由于 J....","articleStatus":0,"articlePermalink":"/articles/2020/12/14/1607958194047.html","articleImg1URL":"https://b3logfile.com/file/2020/12/image-c4b49cde.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"},{"articleTitle":"Jdk 自带工具","articleAbstractText":"jps, jstat, jinfo, jstack, jmap, jconsole, visualVm jps java 进程状况查看 jps -q 只显示进程号 jps -m 查看启动类 jps -v 查看详细启动参数 jstat jstat -class 显示类加载情况 jstat -gc [统计间隔] [统计次数] 查看 gc情况 S0C S1C S0U S1U EC EU OC OU MC MU CCSC CCSU YGC YGCT FGC FGCT CGC CGCT GCT 44480.0 44480.0 0.0 8352.5 355840.0 352724.5 889256.0 296943.0 522908.0 503674.2 67120.0 59766.6 6169 27.923 6 6.963 50 6.401 41.287 C: capacity U: used S0: suvivor0 S1: suvivor1 E: eden O: old M: metaspace CCS: 压缩类 C: count T: time 时间 YG: 年轻代GC FG: fullg....","articleStatus":0,"articlePermalink":"/articles/2021/04/10/1618066015513.html","articleImg1URL":"https://b3logfile.com/bing/20180529.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"记一次线上 JAVA 程序 OOM 事件","articleAbstractText":"依赖三方包:  &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.5.13&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 阿里云SLS提供的SDK --&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun.openservices&lt;/groupId&gt; &lt;artifactId&gt;aliyun-log&lt;/artifactId&gt; &lt;version&gt;0.6.56&lt;/version&gt; &lt;/dependency&gt;  代码: public class DefaultServiceClient2 extends DefaultServiceClient { // 问题的主要原因出在这个 DefaultServiceCl....","articleStatus":0,"articlePermalink":"/articles/2021/06/03/1622734827959.html","articleImg1URL":"https://b3logfile.com/file/2021/06/image-2cdfa530.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"},{"articleTitle":"JVM GC","articleAbstractText":"对象引用   强引用   软引用 OOM 之前回收   弱引用 GC 扫描到就回收   幻象引用 不可使用   对象存活分析   引用计数   可达性分析 GCRoots:  栈上引用 存货的线程 方法区静态变量引用 方法区常量引用 本地方法栈引用    对象晋级原则   MinorGC  Eden 区进入 Suvivor 区 Suvivor 区对象年龄 +1 Suvivor 对象年龄达到 15(MaxTenuringThreshold 可以设置， CMS 为 4), 晋级到老年代 Suvivor 对象年龄从小到大计算总和， 到达 50%, 超过的年龄将作为新的年龄上限 大对象无法在新生代分配， 直接分配在老年代    MajorGC 只有 CMS 可以独立执行， 其他回收器都会伴随 MinorGC.   垃圾回收算法  复制 标记清除 标记整理  经典垃圾回收器  Serial/Serial Old 初代 GC, 单线程模式， 必须要 Stop The World SerialOld 是最经典的老年代 GC, 可以与任意的新生代 GC 一同使用 ParNew/ConcurrentMa....","articleStatus":0,"articlePermalink":"/articles/2020/10/12/1602514470235.html","articleImg1URL":"https://b3logfile.com/file/2020/10/image-38471810.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"},{"articleTitle":"JVM类加载过程","articleAbstractText":"类加载过程包括加载, 验证, 准备, 解析, 初始化.","articleStatus":0,"articlePermalink":"/articles/2020/10/12/1602512919868.html","articleImg1URL":"https://b3logfile.com/bing/20180911.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"}]}