{"relevantArticles":[{"articleTitle":"Java JMM","articleAbstractText":"JVM 使用线程工作内存和主内存这两个概念来抽象物理内存结构， 从而屏蔽掉各平台各操作系统的内存结构差异。 JMM 为保障这套抽象内存结构的并发安全， 提供了协议和工具的支持。","articleStatus":0,"articlePermalink":"/articles/2020/12/06/1607225846315.html","articleImg1URL":"https://b3logfile.com/bing/20180913.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"记一次线上 JAVA 程序 OOM 事件","articleAbstractText":"依赖三方包:  &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.5.13&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 阿里云SLS提供的SDK --&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun.openservices&lt;/groupId&gt; &lt;artifactId&gt;aliyun-log&lt;/artifactId&gt; &lt;version&gt;0.6.56&lt;/version&gt; &lt;/dependency&gt;  代码: public class DefaultServiceClient2 extends DefaultServiceClient { // 问题的主要原因出在这个 DefaultServiceCl....","articleStatus":0,"articlePermalink":"/articles/2021/06/03/1622734827959.html","articleImg1URL":"https://b3logfile.com/file/2021/06/image-2cdfa530.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"},{"articleTitle":"Java AQS","articleAbstractText":"AQS AbstractQueuedSynchronizer, 队列同步器， 支持队列等待。 继承自 AbstractOwnableSynchronizer, 不带队列的同步器， 只能有一个线程同步， 其他线程忽略。 AQS 使用 state 和 一个 FIFO 队列来进行线程同步。 state 表示申请资源的状态， 默认 0, 若已被占用则小于 0. AQS 不关注申请和释放资源的方式， 只提供了操作 state 的方法。 在并发申请资源过程， AQS 维护各个线程获取资源的原则， 如不满足获取资源的条件， 则先将它们放入等待队列， 等待资源可以被申请了， 再唤醒等待队列中的线程。 申请和释放资源的方法需要锁自己实现：  1// 尝试申请资源  2boolean tryAcquire(int arg)  3// 尝试释放资源  4boolean tryRelease(int arg)  5// 资源是否被独占  6boolean isHeldExclusively()  7// 尝试以共享模式申请资源  8int tryAcquireShared(int arg)  9// 尝试以共....","articleStatus":0,"articlePermalink":"/articles/2020/12/06/1607259469668.html","articleImg1URL":"https://b3logfile.com/bing/20180117.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"Java 方法调用的底层实现","articleAbstractText":"Java 方法调用通过字节码指令 invokestatic, invokespecial, invokevirtual, invokeinterface, invokedynamic 来实现方法调用. 非虚方法 非虚方法指能够在运行时直接确定其调用地址的方法, 这些方法在类加载完成之后, 其内存地址都是不会再变化的, 可以直接访问调用. invokestatic: 静态方法调用 invokespecial: 私有实例方法调用, 构造方法或 super 方法, 被 final 修饰的实例方法 虚方法 由于多态的特性, 方法可以被不同的子类覆写, 所以对于同一个方法, 它们的实现不同, 对应的方法的目标地址也是不一样的, 通过查方法表来实现动态调用. invokevirtual: 可被覆写的实例方法, 大部分调用方法都是这种方式. Java 对象的方法表存放在类中(与 C++不相同), 从对象实际类型开始递归向上查找类型的方法表, 第一次执行过后, 以方法位置作为索引编号建立缓存 invokeinterface: 类似invokevirtual, 但比较慢, 因为接口中方法的位置编号是无法....","articleStatus":0,"articlePermalink":"/articles/2021/04/09/1617954923009.html","articleImg1URL":"https://b3logfile.com/bing/20190930.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"Jdk 自带工具","articleAbstractText":"jps, jstat, jinfo, jstack, jmap, jconsole, visualVm jps java 进程状况查看 jps -q 只显示进程号 jps -m 查看启动类 jps -v 查看详细启动参数 jstat jstat -class 显示类加载情况 jstat -gc [统计间隔] [统计次数] 查看 gc情况 S0C S1C S0U S1U EC EU OC OU MC MU CCSC CCSU YGC YGCT FGC FGCT CGC CGCT GCT 44480.0 44480.0 0.0 8352.5 355840.0 352724.5 889256.0 296943.0 522908.0 503674.2 67120.0 59766.6 6169 27.923 6 6.963 50 6.401 41.287 C: capacity U: used S0: suvivor0 S1: suvivor1 E: eden O: old M: metaspace CCS: 压缩类 C: count T: time 时间 YG: 年轻代GC FG: fullg....","articleStatus":0,"articlePermalink":"/articles/2021/04/10/1618066015513.html","articleImg1URL":"https://b3logfile.com/bing/20180529.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"}]}