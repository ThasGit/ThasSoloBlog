{"relevantArticles":[{"articleTitle":"JVM GC","articleAbstractText":"对象引用   强引用   软引用 OOM 之前回收   弱引用 GC 扫描到就回收   幻象引用 不可使用   对象存活分析   引用计数   可达性分析 GCRoots:  栈上引用 存货的线程 方法区静态变量引用 方法区常量引用 本地方法栈引用    对象晋级原则   MinorGC  Eden 区进入 Suvivor 区 Suvivor 区对象年龄 +1 Suvivor 对象年龄达到 15(MaxTenuringThreshold 可以设置， CMS 为 4), 晋级到老年代 Suvivor 对象年龄从小到大计算总和， 到达 50%, 超过的年龄将作为新的年龄上限 大对象无法在新生代分配， 直接分配在老年代    MajorGC 只有 CMS 可以独立执行， 其他回收器都会伴随 MinorGC.   垃圾回收算法  复制 标记清除 标记整理  经典垃圾回收器  Serial/Serial Old 初代 GC, 单线程模式， 必须要 Stop The World SerialOld 是最经典的老年代 GC, 可以与任意的新生代 GC 一同使用 ParNew/ConcurrentMa....","articleStatus":0,"articlePermalink":"/articles/2020/10/12/1602514470235.html","articleImg1URL":"https://b3logfile.com/file/2020/10/image-38471810.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"},{"articleTitle":"JAVA 对象头","articleAbstractText":"对象头结构  偏向锁与 hash 不能共存， 一旦计算过 hash, 对象就不可偏向。 对象头中的 bl:1 代表是否可偏向， 若不可偏向， 则前 56 位可以用来表示 hash 值， 若可偏向， 则前 56 位必不表示 hash 值， 可以用来表示偏向的线程 ID  Object 没有属性， 所以除了对象头就没有其他内容了， 根据 8 字节对齐， 自动填充了 4 字节 Object[]数组会额外使用 4 字节保存长度， 所以数组的最大长度为整形; 后面则是顺序存储的全部元素的指针， 由于开启了指针压缩， 每个都是 4 个字节。  指针压缩 32 位 CPU 的最大寻址空间为 2^32, 如果这些寻址空间指向 bit 位， 那么最大支持的内存为 512M; 但是 CPU 存储数据的时候都是以 8bit 为一组， 也就是 1byte; 把寻址空间指向 byte 组， 就可以让最大支持内存增加到 4G. JVM 指针压缩原理相同。 64 位 JVM 最大寻址空间是 2^64, 寻址空间指向 byte 组， 则最大可支持 2^34G 内存; 但是存储 64 位指针会让内存占用提高。 由于 J....","articleStatus":0,"articlePermalink":"/articles/2020/12/14/1607958194047.html","articleImg1URL":"https://b3logfile.com/file/2020/12/image-c4b49cde.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"},{"articleTitle":"Java AQS","articleAbstractText":"AQS AbstractQueuedSynchronizer, 队列同步器， 支持队列等待。 继承自 AbstractOwnableSynchronizer, 不带队列的同步器， 只能有一个线程同步， 其他线程忽略。 AQS 使用 state 和 一个 FIFO 队列来进行线程同步。 state 表示申请资源的状态， 默认 0, 若已被占用则小于 0. AQS 不关注申请和释放资源的方式， 只提供了操作 state 的方法。 在并发申请资源过程， AQS 维护各个线程获取资源的原则， 如不满足获取资源的条件， 则先将它们放入等待队列， 等待资源可以被申请了， 再唤醒等待队列中的线程。 申请和释放资源的方法需要锁自己实现：  1// 尝试申请资源  2boolean tryAcquire(int arg)  3// 尝试释放资源  4boolean tryRelease(int arg)  5// 资源是否被独占  6boolean isHeldExclusively()  7// 尝试以共享模式申请资源  8int tryAcquireShared(int arg)  9// 尝试以共....","articleStatus":0,"articlePermalink":"/articles/2020/12/06/1607259469668.html","articleImg1URL":"https://b3logfile.com/bing/20180117.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"JVM类加载过程","articleAbstractText":"类加载过程包括加载, 验证, 准备, 解析, 初始化.","articleStatus":0,"articlePermalink":"/articles/2020/10/12/1602512919868.html","articleImg1URL":"https://b3logfile.com/bing/20180911.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"Java 方法调用的底层实现","articleAbstractText":"Java 方法调用通过字节码指令 invokestatic, invokespecial, invokevirtual, invokeinterface, invokedynamic 来实现方法调用. 非虚方法 非虚方法指能够在运行时直接确定其调用地址的方法, 这些方法在类加载完成之后, 其内存地址都是不会再变化的, 可以直接访问调用. invokestatic: 静态方法调用 invokespecial: 私有实例方法调用, 构造方法或 super 方法, 被 final 修饰的实例方法 虚方法 由于多态的特性, 方法可以被不同的子类覆写, 所以对于同一个方法, 它们的实现不同, 对应的方法的目标地址也是不一样的, 通过查方法表来实现动态调用. invokevirtual: 可被覆写的实例方法, 大部分调用方法都是这种方式. Java 对象的方法表存放在类中(与 C++不相同), 从对象实际类型开始递归向上查找类型的方法表, 第一次执行过后, 以方法位置作为索引编号建立缓存 invokeinterface: 类似invokevirtual, 但比较慢, 因为接口中方法的位置编号是无法....","articleStatus":0,"articlePermalink":"/articles/2021/04/09/1617954923009.html","articleImg1URL":"https://b3logfile.com/bing/20190930.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"}]}