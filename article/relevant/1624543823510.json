{"relevantArticles":[{"articleTitle":"SQL 优化的几种方式","articleAbstractText":"高性能索引 建立三星索引： 一星：根据索引能够确定一段较小的范围，散列好的字段靠前 二星：查询结果排序与索引排序一致，联合索引从做到右有序。 三星：宽索引，查询结果尽可能在索引中找到（覆盖索引），避免回表 索引使用注意点：  不要在索引列上做运算 尽可能全值匹配 （唯一确定一条索引） 最左匹配原则 范围条件放最后 覆盖索引 不等于要慎用 Null 和 Not Null， 尽可能不要使用null， null有很歧义 like查询只能匹配做前缀 字符串要加引号 or的所有条件都必须要有索引，否则会全表扫描 使用索引排序来做排序，从左到右依次有序，中间索引单独排列是无序的 使用自增主键，顺序插入（MySQL B+树特性）  移除无用的索引 插入或修改数据都需要修改索引，无用索引会浪费插入时的性能。 分页优化 分页查询时，offset的那部分依然会被查询到，只是在返回客户端时被丢弃了 （也就是查询到了大量不必要的数据），先根据条件查询 ID（不回表），再根据ID查询其他字段（子查询）。 此种办法会多物化出一个子查询结果集。 通过手动指定 MaxId 限定查询的起始位置。 查询降级 当查询无可避....","articleStatus":0,"articlePermalink":"/articles/2021/07/04/1625395418760.html","articleImg1URL":"https://b3logfile.com/bing/20190423.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"MySQL 事务","articleAbstractText":"事务特性:  原子性 一致性 隔离性 持久性  事务并发问题:  脏读 读到了未提交的事务 脏写 未提交的事务覆盖了已提交的事务 幻读 读到了别人新插入的数据 不可重复读 多次读取数据不一样, 被已提交的事务修改了值 写入偏差 已提交的事务覆盖了已提交的事务, 造成了不一致的问题, 通常是业务上进行保证  事务隔离级别:  读未提交 基本不用, 脏读,脏写,幻读,不可重复读均存在 读已提交 用的比较多, 不能避免幻读, 不可重复读 可重复读 存在幻读问题, MySQL使用间隙锁解决了幻读问题 串行化 基本不用, 无高性能","articleStatus":0,"articlePermalink":"/articles/2021/06/24/1624543316182.html","articleImg1URL":"https://b3logfile.com/bing/20200720.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"MySQL 体系架构","articleAbstractText":"MySQL架构分为3部分, 连接层, Server层, 引擎层. 连接层负责服务端与客户端的连接, 会话和权限验证. Server层包括SQL接口, 解析器, 优化器和查询器. 引擎层则是数据存储的具体的实现.","articleStatus":0,"articlePermalink":"/articles/2021/06/06/1622983424981.html","articleImg1URL":"https://b3logfile.com/file/2021/06/mysql体系架构-e57ace13.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"}]}