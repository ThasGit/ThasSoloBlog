{"relevantArticles":[{"articleTitle":"Jdk 自带工具","articleAbstractText":"jps, jstat, jinfo, jstack, jmap, jconsole, visualVm jps java 进程状况查看 jps -q 只显示进程号 jps -m 查看启动类 jps -v 查看详细启动参数 jstat jstat -class 显示类加载情况 jstat -gc [统计间隔] [统计次数] 查看 gc情况 S0C S1C S0U S1U EC EU OC OU MC MU CCSC CCSU YGC YGCT FGC FGCT CGC CGCT GCT 44480.0 44480.0 0.0 8352.5 355840.0 352724.5 889256.0 296943.0 522908.0 503674.2 67120.0 59766.6 6169 27.923 6 6.963 50 6.401 41.287 C: capacity U: used S0: suvivor0 S1: suvivor1 E: eden O: old M: metaspace CCS: 压缩类 C: count T: time 时间 YG: 年轻代GC FG: fullg....","articleStatus":0,"articlePermalink":"/articles/2021/04/10/1618066015513.html","articleImg1URL":"https://b3logfile.com/bing/20180529.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"Java8 ConcurrentHashMap","articleAbstractText":"ConcurrentHashMap 是 HashMap 的线程安全版本， 使用了 CAS, volatile 和 synchronize 技术。  初始化时使用 volatile 修饰的 sizeCtl 作为互斥条件， 如果有其他线程正在操作则 Thread.yeild(). 在插入元素时， 如果元素不存在， 则使用 CAS, 在插入新元素时， 如果元素不存在才能插入成功， 否则失败重试， 如果是 MOVED 状态， 则先辅助扩容， 完成后再尝试插入。 如果元素存在， 需要进行修改或者 Hash 冲突， 则加 synchronize 锁进行处理(因为情况比较复杂， 可能是链表， 可能还需要树化), synchronize 修饰 bin 上的第一个元素 元素数量修改时， 并发高的情况容易 CAS 失败， 引入 counterCells 数组减小 CAS 失败的概率 数组扩容时， 分段迁移， 每段最少 16, 迁移前 CAS 设置 transferIndex, 设置成功则得到该小段的迁移的权利。 迁移时， 如果该 bin 上有值， 则 synchronize 锁住， 如果无值， 则 CAS....","articleStatus":0,"articlePermalink":"/articles/2020/12/05/1607178489851.html","articleImg1URL":"https://b3logfile.com/bing/20181124.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"记一次线上 JAVA 程序 OOM 事件","articleAbstractText":"依赖三方包:  &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.5.13&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 阿里云SLS提供的SDK --&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun.openservices&lt;/groupId&gt; &lt;artifactId&gt;aliyun-log&lt;/artifactId&gt; &lt;version&gt;0.6.56&lt;/version&gt; &lt;/dependency&gt;  代码: public class DefaultServiceClient2 extends DefaultServiceClient { // 问题的主要原因出在这个 DefaultServiceCl....","articleStatus":0,"articlePermalink":"/articles/2021/06/03/1622734827959.html","articleImg1URL":"https://b3logfile.com/file/2021/06/image-2cdfa530.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"},{"articleTitle":"Java 方法调用的底层实现","articleAbstractText":"Java 方法调用通过字节码指令 invokestatic, invokespecial, invokevirtual, invokeinterface, invokedynamic 来实现方法调用. 非虚方法 非虚方法指能够在运行时直接确定其调用地址的方法, 这些方法在类加载完成之后, 其内存地址都是不会再变化的, 可以直接访问调用. invokestatic: 静态方法调用 invokespecial: 私有实例方法调用, 构造方法或 super 方法, 被 final 修饰的实例方法 虚方法 由于多态的特性, 方法可以被不同的子类覆写, 所以对于同一个方法, 它们的实现不同, 对应的方法的目标地址也是不一样的, 通过查方法表来实现动态调用. invokevirtual: 可被覆写的实例方法, 大部分调用方法都是这种方式. Java 对象的方法表存放在类中(与 C++不相同), 从对象实际类型开始递归向上查找类型的方法表, 第一次执行过后, 以方法位置作为索引编号建立缓存 invokeinterface: 类似invokevirtual, 但比较慢, 因为接口中方法的位置编号是无法....","articleStatus":0,"articlePermalink":"/articles/2021/04/09/1617954923009.html","articleImg1URL":"https://b3logfile.com/bing/20190930.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"JAVA 对象头","articleAbstractText":"对象头结构  偏向锁与 hash 不能共存， 一旦计算过 hash, 对象就不可偏向。 对象头中的 bl:1 代表是否可偏向， 若不可偏向， 则前 56 位可以用来表示 hash 值， 若可偏向， 则前 56 位必不表示 hash 值， 可以用来表示偏向的线程 ID  Object 没有属性， 所以除了对象头就没有其他内容了， 根据 8 字节对齐， 自动填充了 4 字节 Object[]数组会额外使用 4 字节保存长度， 所以数组的最大长度为整形; 后面则是顺序存储的全部元素的指针， 由于开启了指针压缩， 每个都是 4 个字节。  指针压缩 32 位 CPU 的最大寻址空间为 2^32, 如果这些寻址空间指向 bit 位， 那么最大支持的内存为 512M; 但是 CPU 存储数据的时候都是以 8bit 为一组， 也就是 1byte; 把寻址空间指向 byte 组， 就可以让最大支持内存增加到 4G. JVM 指针压缩原理相同。 64 位 JVM 最大寻址空间是 2^64, 寻址空间指向 byte 组， 则最大可支持 2^34G 内存; 但是存储 64 位指针会让内存占用提高。 由于 J....","articleStatus":0,"articlePermalink":"/articles/2020/12/14/1607958194047.html","articleImg1URL":"https://b3logfile.com/file/2020/12/image-c4b49cde.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"}]}