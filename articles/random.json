{"randomArticles":[{"articleTitle":"SQL 优化的几种方式","articleAbstractText":"高性能索引 建立三星索引： 一星：根据索引能够确定一段较小的范围，散列好的字段靠前 二星：查询结果排序与索引排序一致，联合索引从做到右有序。 三星：宽索引，查询结果尽可能在索引中找到（覆盖索引），避免回表 索引使用注意点：  不要在索引列上做运算 尽可能全值匹配 （唯一确定一条索引） 最左匹配原则 范围条件放最后 覆盖索引 不等于要慎用 Null 和 Not Null， 尽可能不要使用null， null有很歧义 like查询只能匹配做前缀 字符串要加引号 or的所有条件都必须要有索引，否则会全表扫描 使用索引排序来做排序，从左到右依次有序，中间索引单独排列是无序的 使用自增主键，顺序插入（MySQL B+树特性）  移除无用的索引 插入或修改数据都需要修改索引，无用索引会浪费插入时的性能。 分页优化 分页查询时，offset的那部分依然会被查询到，只是在返回客户端时被丢弃了 （也就是查询到了大量不必要的数据），先根据条件查询 ID（不回表），再根据ID查询其他字段（子查询）。 此种办法会多物化出一个子查询结果集。 通过手动指定 MaxId 限定查询的起始位置。 查询降级 当查询无可避....","articleStatus":0,"articlePermalink":"/articles/2021/07/04/1625395418760.html","articleImg1URL":"https://b3logfile.com/bing/20180214.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"Spring的BeanFactory","articleAbstractText":"Spring BeanFactory = 简单工厂模式 + 策略模式 + Scope + 定制单例容器 +其他增强功能","articleStatus":0,"articlePermalink":"/articles/2020/06/21/1592752216225.html","articleImg1URL":"https://b3logfile.com/bing/20180617.jpg?imageView2/1/w/960/h/540/interlace/1/q/100"},{"articleTitle":"Jdk 自带工具","articleAbstractText":"jps, jstat, jinfo, jstack, jmap, jconsole, visualVm jps java 进程状况查看 jps -q 只显示进程号 jps -m 查看启动类 jps -v 查看详细启动参数 jstat jstat -class 显示类加载情况 jstat -gc [统计间隔] [统计次数] 查看 gc情况 S0C S1C S0U S1U EC EU OC OU MC MU CCSC CCSU YGC YGCT FGC FGCT CGC CGCT GCT 44480.0 44480.0 0.0 8352.5 355840.0 352724.5 889256.0 296943.0 522908.0 503674.2 67120.0 59766.6 6169 27.923 6 6.963 50 6.401 41.287 C: capacity U: used S0: suvivor0 S1: suvivor1 E: eden O: old M: metaspace CCS: 压缩类 C: count T: time 时间 YG: 年轻代GC FG: fullg....","articleStatus":0,"articlePermalink":"/articles/2021/04/10/1618066015513.html","articleImg1URL":"https://b3logfile.com/bing/20180529.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"Java8 ConcurrentHashMap","articleAbstractText":"ConcurrentHashMap 是 HashMap 的线程安全版本， 使用了 CAS, volatile 和 synchronize 技术。  初始化时使用 volatile 修饰的 sizeCtl 作为互斥条件， 如果有其他线程正在操作则 Thread.yeild(). 在插入元素时， 如果元素不存在， 则使用 CAS, 在插入新元素时， 如果元素不存在才能插入成功， 否则失败重试， 如果是 MOVED 状态， 则先辅助扩容， 完成后再尝试插入。 如果元素存在， 需要进行修改或者 Hash 冲突， 则加 synchronize 锁进行处理(因为情况比较复杂， 可能是链表， 可能还需要树化), synchronize 修饰 bin 上的第一个元素 元素数量修改时， 并发高的情况容易 CAS 失败， 引入 counterCells 数组减小 CAS 失败的概率 数组扩容时， 分段迁移， 每段最少 16, 迁移前 CAS 设置 transferIndex, 设置成功则得到该小段的迁移的权利。 迁移时， 如果该 bin 上有值， 则 synchronize 锁住， 如果无值， 则 CAS....","articleStatus":0,"articlePermalink":"/articles/2020/12/05/1607178489851.html","articleImg1URL":"https://b3logfile.com/bing/20181124.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"MySQL 体系架构","articleAbstractText":"MySQL架构分为3部分, 连接层, Server层, 引擎层. 连接层负责服务端与客户端的连接, 会话和权限验证. Server层包括SQL接口, 解析器, 优化器和查询器. 引擎层则是数据存储的具体的实现.","articleStatus":0,"articlePermalink":"/articles/2021/06/06/1622983424981.html","articleImg1URL":"https://b3logfile.com/file/2021/06/mysql体系架构-e57ace13.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"}]}